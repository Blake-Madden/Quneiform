
```{r}
#| include: false
#| eval: true

source('../R/appdown.r')
```

# Internationalization Issues

Internationalization (i18n) occurs during the development stage of software, which includes (but not limited to) the following areas:

- Preparing the program to display numbers and dates using the client's regional settings.
- Exposing strings for translation.
- Ensuring that strings not meant for translation are not exposed to translators.

I18N issues include any problems during this stage which will later affect either translation efforts or regional display issues for clients.
This chapter will discuss these various issues and provide recommendations for how to detect and correct them using *Quneiform*.

## Embedded Strings {#sec-embedded-strings}

Embedded strings are strings that are hard coded in source code and not made available for translation.

It is recommended to expose these strings to translators via mechanisms such as *gettext* functions, string tables, \*.resx files, etc.

## Concatenated Strings {#sec-concatenated-strings}

When multiple strings are pieced together at runtime, this creates a concatenated string.
Consider the following code sample:

```{RCpp}
wxString TOO_DIFFICULT_DESCRIPTION =
            _(L"Text is too difficult to be classified to a specific grade level because "
              "it contains too many ");
TOO_DIFFICULT_DESCRIPTION += fryGraph->GetScores().front().IsWordsHard() ?
                            _(L"high syllable words.") :
                            _(L"long sentences.");
```

Here, we see a string "...it contains too many " being concatenated with either "high syllable words." or "long sentences.".
This is an issue because it assumes that translations will follow the same word ordering and grammar as the source language.
Also, it fails to provide context to the translator as to what all is being combined into this message.
Rather than seeing a single message, translators are faced with multiple string resources without knowing that they even relate to each other.

In this example, the solution is to create two full (albeit lengthy) string resources for both variations of the possible message.

## Multipart Strings {#sec-multipart-strings}

Multipart strings (or "mega strings") are single string resources that are split at runtime into smaller strings [@madden:2019].

For example, consider a resource string such as:

`"Name      Password  Domain    "`

While this is one string, it contains suspicious looking blocks of spaces in between each word.
As it turns out, an application may be splitting this string into 10-character sections at runtime:

```{r}
#| echo: false
#| out-width: 100%
#| fig-format: png
#| fig-align: center
library(DiagrammeR)

DiagrammeR('
  graph TB
    A["“Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Password&nbsp;&nbsp;Domain&nbsp;&nbsp;&nbsp;&nbsp;”"]-->B["“Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”"]
    A["“Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Password&nbsp;&nbsp;Domain&nbsp;&nbsp;&nbsp;&nbsp;”"]-->C["“Password&nbsp;&nbsp;”"]
    A["“Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Password&nbsp;&nbsp;Domain&nbsp;&nbsp;&nbsp;&nbsp;”"]-->D["“Domain&nbsp;&nbsp;&nbsp;&nbsp;”"]
')
```

Then, it will use each of these sections as a separate resource.
This is a bad practice found in legacy software, and can be thought of as the opposite of concatenating strings (another bad i18n practice).

The issue with this practice is that it forces translations to a constrained length (10-characters for each word in this example).
Next, it is difficult to translate, as the translator must count the characters and spaces for each word segment, not just the entire string.
(And this is assuming that the behavior of this string was even communicated to the translators.)
Finally, l10n quality assurance tools are not designed to check unusual strings like this.
Validating translations for these resources requires custom tools, which creates unnecessary technical debt.

If a translator doesn't format each segment of this string perfectly, then at best the translations will overlap or be clipped at runtime.
At worst, the program will crash in situations where the full string is less than 30 characters.

It is preferred to use separate resources for each string.
This ensures that the translations aren't constrained to arbitrary lengths and QA tools will be able to review the resources with ease.
